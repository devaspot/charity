functor chLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : ch_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
(* the yacc file for charity *)
open AST

(* code to decide whether it is a inductive or co-inductive data definition
   why do we do it here? Because we are building an *abstract* syntax tree.
   Conceptually, the syntax tree should differentiate these two.
 *)
local
    fun matchResultType x (_, SOME (yARROW(_,yNAME(y,[])))) = x=y
      | matchResultType x (_, NONE) = true
      | matchResultType x _ = false

    fun matchSourceType x (_, SOME (yARROW([],_))) = false
      | matchSourceType x (_, SOME (yARROW([yNAME(y,[])],_))) = x=y
      | matchSourceType x (_, SOME (yARROW(tl,_))) =
            (case List.last tl
            of yNAME(y,[]) => x=y
            | _ => false
            )
      | matchSourceType x _ = false
in
    (* is it an inductive datatype? *)
    fun isInductive aDef =
            (case aDef
               of ((aname,_), (alias, []), structorList) =>
                           List.all (matchResultType alias) structorList
                | _ => false
            )
            (* is it an coinductive datatype? *)
    fun isCoinductive aDef =
            (case aDef
               of ((alias,[]),_, structorList) =>
                           List.all (matchSourceType alias) structorList
                | _ => false
            )
end
 (*
   The first arg is a pattern, the second is a term.
   map (addpattern x) [(dtr1,y), (dtr2, z=>t),...] will
   convert (| x => dtr1: y
                 | dtr2: z=> t
                 ...
                 |)
   into (| dtr1: x=> y
         | dtr2: z,x => t
         ...
         |)
   It's more consistent with the syntax of fold, also more convenient when we use patterns
 *)
fun addpattern aPatt (name, yPattABS(patabslst)) =
        (name, yPattABS( map (fn (patlst,t) => (patlst @ [aPatt], t) )
                             patabslst

                       )
        )
  | addpattern aPatt (name,aTerm) = (name, yPattABS([([aPatt], aTerm)]))

fun countRecurParams [] = 0
  | countRecurParams ((_,1)::rps) = 1+countRecurParams rps
  | countRecurParams (_::rps) = countRecurParams rps

fun findRecurPos [] = raise Fail("findRecurPos")
  | findRecurPos((_,1)::_) = 0
  | findRecurPos(_::rps) = 1+(findRecurPos rps)

fun buildNewBody(paramList:(string*int) list, fbody: YTerm) = 
    (* convert <f(#p1,@p2,p3) = patterns> into <f = p1,p2,p3 => (p1,p3);patterns> *)
    if countRecurParams paramList >1 then
        raise YACCERR("Can not have more than one recursive parameters")
    else
        let fun getPatternedVars([]) = []
              | getPatternedVars((id,0)::pl) = id::(getPatternedVars pl)
              | getPatternedVars((id,1)::pl) = id::(getPatternedVars pl)
              | getPatternedVars((id,2)::pl) = (getPatternedVars pl)
            
            val pvarlst = getPatternedVars paramList
            fun toTerm [x] = yVAR x
              | toTerm lst = yTUPLE(map yVAR lst)
        in
            yPattABS([(map ypVAR (map #1 paramList), 
                       yAPP(fbody, toTerm pvarlst)
                      )])
        end
                      



(*originally I used the %pure directive, then strange things happens when there is a parsing error.
  The lesson is that if you used exceptions or any imperative instructions, don't use the %pure
 *)

end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\117\001\002\000\117\001\007\000\117\001\008\000\117\001\
\\009\000\117\001\012\000\122\001\015\000\117\001\016\000\122\001\
\\017\000\117\001\018\000\122\001\019\000\117\001\020\000\122\001\
\\021\000\117\001\022\000\122\001\023\000\117\001\024\000\122\001\
\\027\000\117\001\028\000\122\001\030\000\122\001\031\000\122\001\
\\032\000\122\001\033\000\122\001\035\000\122\001\036\000\122\001\
\\037\000\122\001\038\000\122\001\039\000\122\001\040\000\117\001\
\\041\000\122\001\042\000\122\001\043\000\122\001\044\000\122\001\
\\045\000\122\001\046\000\122\001\047\000\122\001\048\000\122\001\
\\049\000\122\001\050\000\122\001\051\000\122\001\052\000\122\001\
\\053\000\122\001\054\000\122\001\055\000\122\001\056\000\122\001\
\\057\000\122\001\058\000\122\001\059\000\117\001\061\000\122\001\
\\062\000\122\001\063\000\122\001\064\000\122\001\065\000\122\001\000\000\
\\001\000\001\000\117\001\002\000\117\001\007\000\117\001\008\000\117\001\
\\009\000\117\001\015\000\117\001\016\000\122\001\017\000\117\001\
\\019\000\117\001\021\000\117\001\023\000\117\001\027\000\117\001\
\\030\000\122\001\031\000\003\001\032\000\122\001\034\000\002\001\
\\035\000\122\001\036\000\122\001\037\000\122\001\038\000\122\001\
\\039\000\122\001\040\000\117\001\041\000\122\001\042\000\122\001\
\\043\000\122\001\044\000\122\001\045\000\122\001\046\000\122\001\
\\047\000\122\001\048\000\122\001\049\000\122\001\050\000\122\001\
\\051\000\122\001\052\000\122\001\053\000\122\001\054\000\122\001\
\\055\000\122\001\056\000\122\001\057\000\122\001\058\000\122\001\
\\059\000\117\001\061\000\122\001\062\000\122\001\000\000\
\\001\000\001\000\014\000\002\000\013\000\003\000\012\000\000\000\
\\001\000\001\000\016\000\000\000\
\\001\000\001\000\018\000\000\000\
\\001\000\001\000\021\000\000\000\
\\001\000\001\000\044\000\007\000\043\000\013\000\042\000\015\000\041\000\000\000\
\\001\000\001\000\044\000\007\000\043\000\015\000\041\000\000\000\
\\001\000\001\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\000\000\
\\001\000\001\000\054\000\000\000\
\\001\000\001\000\088\000\005\000\087\000\000\000\
\\001\000\001\000\090\000\005\000\089\000\000\000\
\\001\000\001\000\105\000\003\000\104\000\000\000\
\\001\000\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\014\000\105\001\015\000\071\000\020\000\117\001\028\000\117\001\
\\030\000\105\001\031\000\117\001\033\000\117\001\063\000\117\001\
\\064\000\117\001\065\000\117\001\000\000\
\\001\000\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\015\000\071\000\000\000\
\\001\000\001\000\112\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\015\000\071\000\016\000\111\000\000\000\
\\001\000\001\000\127\000\002\000\076\000\007\000\126\000\008\000\125\000\
\\009\000\124\000\015\000\123\000\017\000\122\000\018\000\199\000\
\\019\000\121\000\021\000\120\000\023\000\119\000\027\000\069\000\
\\040\000\118\000\059\000\117\000\000\000\
\\001\000\001\000\127\000\002\000\076\000\007\000\126\000\008\000\125\000\
\\009\000\124\000\015\000\123\000\017\000\122\000\019\000\121\000\
\\021\000\120\000\023\000\119\000\027\000\069\000\040\000\118\000\
\\059\000\117\000\000\000\
\\001\000\001\000\142\000\000\000\
\\001\000\001\000\152\000\000\000\
\\001\000\001\000\195\000\000\000\
\\001\000\001\000\204\000\002\000\076\000\007\000\126\000\008\000\125\000\
\\009\000\124\000\015\000\123\000\016\000\203\000\017\000\122\000\
\\019\000\121\000\021\000\120\000\023\000\119\000\027\000\069\000\
\\040\000\118\000\059\000\117\000\000\000\
\\001\000\001\000\216\000\000\000\
\\001\000\001\000\217\000\000\000\
\\001\000\001\000\245\000\002\000\076\000\019\000\121\000\021\000\120\000\
\\023\000\119\000\027\000\069\000\000\000\
\\001\000\001\000\013\001\000\000\
\\001\000\006\000\128\000\000\000\
\\001\000\007\000\129\000\000\000\
\\001\000\012\000\055\001\014\000\057\001\030\000\079\000\033\000\055\001\
\\063\000\055\001\064\000\055\001\065\000\055\001\000\000\
\\001\000\012\000\146\001\016\000\146\001\018\000\146\001\020\000\146\001\
\\022\000\146\001\024\000\146\001\028\000\146\001\030\000\146\001\
\\031\000\146\001\032\000\146\001\033\000\146\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\146\001\057\000\146\001\058\000\146\001\
\\061\000\162\000\062\000\161\000\063\000\146\001\064\000\146\001\
\\065\000\146\001\000\000\
\\001\000\012\000\147\001\016\000\147\001\018\000\147\001\020\000\147\001\
\\022\000\147\001\024\000\147\001\028\000\147\001\030\000\147\001\
\\031\000\147\001\032\000\147\001\033\000\147\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\147\001\057\000\147\001\058\000\147\001\
\\061\000\162\000\062\000\161\000\063\000\147\001\064\000\147\001\
\\065\000\147\001\000\000\
\\001\000\012\000\148\001\016\000\148\001\018\000\148\001\020\000\148\001\
\\022\000\148\001\024\000\148\001\028\000\148\001\030\000\148\001\
\\031\000\148\001\032\000\148\001\033\000\148\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\148\001\057\000\148\001\058\000\148\001\
\\061\000\162\000\062\000\161\000\063\000\148\001\064\000\148\001\
\\065\000\148\001\000\000\
\\001\000\012\000\149\001\016\000\149\001\018\000\149\001\020\000\149\001\
\\022\000\149\001\024\000\149\001\028\000\149\001\030\000\149\001\
\\031\000\149\001\032\000\149\001\033\000\149\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\149\001\057\000\149\001\058\000\149\001\
\\061\000\162\000\062\000\161\000\063\000\149\001\064\000\149\001\
\\065\000\149\001\000\000\
\\001\000\012\000\151\001\016\000\151\001\018\000\151\001\020\000\151\001\
\\022\000\151\001\024\000\151\001\028\000\151\001\030\000\151\001\
\\031\000\151\001\032\000\151\001\033\000\151\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\151\001\057\000\151\001\058\000\151\001\
\\061\000\162\000\062\000\161\000\063\000\151\001\064\000\151\001\
\\065\000\151\001\000\000\
\\001\000\012\000\152\001\016\000\152\001\018\000\152\001\020\000\152\001\
\\022\000\152\001\024\000\152\001\028\000\152\001\030\000\152\001\
\\031\000\152\001\032\000\152\001\033\000\152\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\152\001\057\000\152\001\058\000\152\001\
\\061\000\162\000\062\000\161\000\063\000\152\001\064\000\152\001\
\\065\000\152\001\000\000\
\\001\000\012\000\153\001\016\000\153\001\018\000\153\001\020\000\153\001\
\\022\000\153\001\024\000\153\001\028\000\153\001\030\000\153\001\
\\031\000\153\001\032\000\153\001\033\000\153\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\153\001\057\000\153\001\058\000\153\001\
\\061\000\162\000\062\000\161\000\063\000\153\001\064\000\153\001\
\\065\000\153\001\000\000\
\\001\000\012\000\154\001\016\000\154\001\018\000\154\001\020\000\154\001\
\\022\000\154\001\024\000\154\001\028\000\154\001\030\000\154\001\
\\031\000\154\001\032\000\154\001\033\000\154\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\154\001\057\000\154\001\058\000\154\001\
\\061\000\162\000\062\000\161\000\063\000\154\001\064\000\154\001\
\\065\000\154\001\000\000\
\\001\000\012\000\155\001\016\000\155\001\018\000\155\001\020\000\155\001\
\\022\000\155\001\024\000\155\001\028\000\155\001\030\000\155\001\
\\031\000\155\001\032\000\155\001\033\000\155\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\155\001\057\000\155\001\058\000\155\001\
\\061\000\162\000\062\000\161\000\063\000\155\001\064\000\155\001\
\\065\000\155\001\000\000\
\\001\000\012\000\156\001\016\000\156\001\018\000\156\001\020\000\156\001\
\\022\000\156\001\024\000\156\001\028\000\156\001\030\000\156\001\
\\031\000\156\001\032\000\156\001\033\000\156\001\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\056\000\156\001\057\000\156\001\058\000\156\001\
\\061\000\162\000\062\000\161\000\063\000\156\001\064\000\156\001\
\\065\000\156\001\000\000\
\\001\000\013\000\027\000\029\000\026\000\000\000\
\\001\000\013\000\080\000\000\000\
\\001\000\013\000\023\001\000\000\
\\001\000\014\000\100\000\000\000\
\\001\000\014\000\247\000\000\000\
\\001\000\014\000\034\001\000\000\
\\001\000\015\000\025\000\000\000\
\\001\000\016\000\086\000\000\000\
\\001\000\016\000\092\000\000\000\
\\001\000\016\000\137\000\000\000\
\\001\000\016\000\155\000\000\000\
\\001\000\016\000\157\000\000\000\
\\001\000\016\000\208\000\000\000\
\\001\000\016\000\255\000\000\000\
\\001\000\016\000\001\001\030\000\000\001\032\000\186\000\035\000\185\000\
\\036\000\184\000\037\000\183\000\038\000\182\000\039\000\181\000\
\\041\000\180\000\042\000\179\000\043\000\178\000\044\000\177\000\
\\045\000\176\000\046\000\175\000\047\000\174\000\048\000\173\000\
\\049\000\172\000\050\000\171\000\051\000\170\000\052\000\169\000\
\\053\000\168\000\054\000\167\000\055\000\166\000\056\000\165\000\
\\057\000\164\000\058\000\163\000\061\000\162\000\062\000\161\000\000\000\
\\001\000\016\000\027\001\000\000\
\\001\000\018\000\252\000\000\000\
\\001\000\020\000\032\000\000\000\
\\001\000\020\000\154\000\000\000\
\\001\000\020\000\206\000\000\000\
\\001\000\020\000\251\000\000\000\
\\001\000\020\000\032\001\000\000\
\\001\000\022\000\249\000\000\000\
\\001\000\024\000\246\000\000\000\
\\001\000\028\000\150\000\000\000\
\\001\000\029\000\035\000\000\000\
\\001\000\029\000\056\000\000\000\
\\001\000\029\000\061\000\000\000\
\\001\000\029\000\091\000\000\000\
\\001\000\029\000\094\000\000\000\
\\001\000\029\000\097\000\000\000\
\\001\000\029\000\145\000\000\000\
\\001\000\029\000\214\000\000\000\
\\001\000\029\000\009\001\000\000\
\\001\000\031\000\159\000\034\000\158\000\000\000\
\\001\000\031\000\250\000\000\000\
\\001\000\031\000\003\001\034\000\002\001\000\000\
\\001\000\037\000\078\000\000\000\
\\001\000\065\000\000\000\000\000\
\\037\001\000\000\
\\038\001\000\000\
\\039\001\000\000\
\\040\001\033\000\011\000\063\000\009\000\064\000\008\000\000\000\
\\040\001\063\000\009\000\064\000\008\000\000\000\
\\041\001\000\000\
\\042\001\000\000\
\\043\001\000\000\
\\044\001\000\000\
\\045\001\015\000\028\000\000\000\
\\046\001\000\000\
\\047\001\030\000\093\000\000\000\
\\048\001\000\000\
\\049\001\012\000\209\000\000\000\
\\050\001\000\000\
\\051\001\031\000\210\000\000\000\
\\052\001\000\000\
\\053\001\000\000\
\\054\001\000\000\
\\055\001\000\000\
\\056\001\000\000\
\\057\001\030\000\079\000\000\000\
\\058\001\000\000\
\\059\001\037\000\078\000\000\000\
\\060\001\000\000\
\\061\001\000\000\
\\062\001\015\000\084\000\000\000\
\\063\001\000\000\
\\064\001\000\000\
\\065\001\037\000\078\000\000\000\
\\066\001\000\000\
\\067\001\000\000\
\\068\001\000\000\
\\069\001\000\000\
\\070\001\000\000\
\\071\001\000\000\
\\072\001\000\000\
\\073\001\000\000\
\\074\001\000\000\
\\075\001\030\000\085\000\000\000\
\\076\001\000\000\
\\077\001\000\000\
\\078\001\000\000\
\\079\001\000\000\
\\080\001\000\000\
\\081\001\000\000\
\\082\001\000\000\
\\083\001\000\000\
\\084\001\015\000\025\000\031\000\024\000\000\000\
\\084\001\031\000\024\000\000\000\
\\085\001\033\000\031\000\000\000\
\\086\001\000\000\
\\087\001\031\000\033\000\000\000\
\\088\001\000\000\
\\089\001\000\000\
\\090\001\000\000\
\\091\001\000\000\
\\092\001\000\000\
\\093\001\031\000\151\000\000\000\
\\094\001\000\000\
\\095\001\000\000\
\\096\001\000\000\
\\097\001\012\000\099\000\000\000\
\\098\001\000\000\
\\099\001\032\000\186\000\035\000\185\000\036\000\184\000\037\000\183\000\
\\038\000\182\000\039\000\181\000\041\000\180\000\042\000\179\000\
\\043\000\178\000\044\000\177\000\045\000\176\000\046\000\175\000\
\\047\000\174\000\048\000\173\000\049\000\172\000\050\000\171\000\
\\051\000\170\000\052\000\169\000\053\000\168\000\054\000\167\000\
\\055\000\166\000\056\000\165\000\057\000\164\000\058\000\163\000\
\\061\000\162\000\062\000\161\000\000\000\
\\100\001\032\000\186\000\035\000\185\000\036\000\184\000\037\000\183\000\
\\038\000\182\000\039\000\181\000\041\000\180\000\042\000\179\000\
\\043\000\178\000\044\000\177\000\045\000\176\000\046\000\175\000\
\\047\000\174\000\048\000\173\000\049\000\172\000\050\000\171\000\
\\051\000\170\000\052\000\169\000\053\000\168\000\054\000\167\000\
\\055\000\166\000\056\000\165\000\057\000\164\000\058\000\163\000\
\\061\000\162\000\062\000\161\000\000\000\
\\101\001\001\000\077\000\002\000\076\000\005\000\075\000\006\000\074\000\
\\007\000\073\000\014\000\072\000\015\000\071\000\019\000\070\000\
\\027\000\069\000\000\000\
\\101\001\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\014\000\072\000\015\000\071\000\000\000\
\\101\001\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\014\000\072\000\015\000\071\000\019\000\070\000\000\000\
\\101\001\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\014\000\072\000\015\000\071\000\019\000\016\001\000\000\
\\102\001\030\000\101\000\000\000\
\\103\001\000\000\
\\104\001\000\000\
\\105\001\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\015\000\071\000\000\000\
\\105\001\001\000\107\000\005\000\075\000\006\000\074\000\007\000\073\000\
\\015\000\071\000\031\000\159\000\034\000\158\000\000\000\
\\106\001\000\000\
\\107\001\000\000\
\\108\001\000\000\
\\109\001\000\000\
\\110\001\007\000\205\000\000\000\
\\111\001\000\000\
\\112\001\000\000\
\\113\001\030\000\156\000\000\000\
\\114\001\000\000\
\\115\001\000\000\
\\116\001\000\000\
\\117\001\000\000\
\\118\001\000\000\
\\119\001\000\000\
\\120\001\033\000\207\000\000\000\
\\121\001\000\000\
\\123\001\000\000\
\\124\001\000\000\
\\125\001\000\000\
\\126\001\000\000\
\\127\001\000\000\
\\128\001\000\000\
\\129\001\000\000\
\\130\001\000\000\
\\131\001\000\000\
\\132\001\000\000\
\\133\001\000\000\
\\134\001\035\000\185\000\036\000\184\000\037\000\183\000\038\000\182\000\
\\039\000\181\000\041\000\180\000\042\000\179\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\046\000\175\000\047\000\174\000\
\\048\000\173\000\049\000\172\000\050\000\171\000\051\000\170\000\
\\052\000\169\000\053\000\168\000\054\000\167\000\055\000\166\000\
\\061\000\162\000\062\000\161\000\000\000\
\\135\001\000\000\
\\136\001\037\000\183\000\038\000\182\000\039\000\181\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\000\000\
\\137\001\037\000\183\000\038\000\182\000\039\000\181\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\000\000\
\\138\001\037\000\183\000\038\000\182\000\039\000\181\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\000\000\
\\139\001\037\000\183\000\038\000\182\000\039\000\181\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\000\000\
\\140\001\000\000\
\\141\001\000\000\
\\142\001\000\000\
\\143\001\000\000\
\\144\001\000\000\
\\145\001\000\000\
\\150\001\037\000\183\000\038\000\182\000\039\000\181\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\000\000\
\\157\001\035\000\185\000\036\000\184\000\037\000\183\000\038\000\182\000\
\\039\000\181\000\041\000\180\000\042\000\179\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\046\000\175\000\047\000\174\000\
\\048\000\173\000\049\000\172\000\050\000\171\000\051\000\170\000\
\\052\000\169\000\053\000\168\000\054\000\167\000\055\000\166\000\
\\061\000\162\000\062\000\161\000\000\000\
\\158\001\035\000\185\000\036\000\184\000\037\000\183\000\038\000\182\000\
\\039\000\181\000\041\000\180\000\042\000\179\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\046\000\175\000\047\000\174\000\
\\048\000\173\000\049\000\172\000\050\000\171\000\051\000\170\000\
\\052\000\169\000\053\000\168\000\054\000\167\000\055\000\166\000\
\\056\000\165\000\061\000\162\000\062\000\161\000\000\000\
\\159\001\035\000\185\000\036\000\184\000\037\000\183\000\038\000\182\000\
\\039\000\181\000\041\000\180\000\042\000\179\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\046\000\175\000\047\000\174\000\
\\048\000\173\000\049\000\172\000\050\000\171\000\051\000\170\000\
\\052\000\169\000\053\000\168\000\054\000\167\000\055\000\166\000\
\\056\000\165\000\061\000\162\000\062\000\161\000\000\000\
\\160\001\035\000\185\000\036\000\184\000\037\000\183\000\038\000\182\000\
\\039\000\181\000\041\000\180\000\042\000\179\000\043\000\178\000\
\\044\000\177\000\045\000\176\000\061\000\162\000\062\000\161\000\000\000\
\\161\001\030\000\028\001\032\000\186\000\035\000\185\000\036\000\184\000\
\\037\000\183\000\038\000\182\000\039\000\181\000\041\000\180\000\
\\042\000\179\000\043\000\178\000\044\000\177\000\045\000\176\000\
\\046\000\175\000\047\000\174\000\048\000\173\000\049\000\172\000\
\\050\000\171\000\051\000\170\000\052\000\169\000\053\000\168\000\
\\054\000\167\000\055\000\166\000\056\000\165\000\057\000\164\000\
\\058\000\163\000\061\000\162\000\062\000\161\000\000\000\
\\162\001\000\000\
\\163\001\030\000\253\000\032\000\186\000\035\000\185\000\036\000\184\000\
\\037\000\183\000\038\000\182\000\039\000\181\000\041\000\180\000\
\\042\000\179\000\043\000\178\000\044\000\177\000\045\000\176\000\
\\046\000\175\000\047\000\174\000\048\000\173\000\049\000\172\000\
\\050\000\171\000\051\000\170\000\052\000\169\000\053\000\168\000\
\\054\000\167\000\055\000\166\000\056\000\165\000\057\000\164\000\
\\058\000\163\000\061\000\162\000\062\000\161\000\000\000\
\\164\001\000\000\
\\165\001\000\000\
\\166\001\000\000\
\\167\001\000\000\
\\168\001\000\000\
\\169\001\000\000\
\\170\001\030\000\254\000\000\000\
\\171\001\000\000\
\\172\001\032\000\186\000\035\000\185\000\036\000\184\000\037\000\183\000\
\\038\000\182\000\039\000\181\000\041\000\180\000\042\000\179\000\
\\043\000\178\000\044\000\177\000\045\000\176\000\046\000\175\000\
\\047\000\174\000\048\000\173\000\049\000\172\000\050\000\171\000\
\\051\000\170\000\052\000\169\000\053\000\168\000\054\000\167\000\
\\055\000\166\000\056\000\165\000\057\000\164\000\058\000\163\000\
\\061\000\162\000\062\000\161\000\000\000\
\\173\001\000\000\
\\174\001\000\000\
\\175\001\012\000\248\000\000\000\
\\176\001\000\000\
\\177\001\000\000\
\\178\001\000\000\
\\179\001\000\000\
\\180\001\000\000\
\\181\001\012\000\025\001\000\000\
\\182\001\000\000\
\"
val actionRowNumbers =
"\082\000\085\000\084\000\083\000\
\\081\000\078\000\002\000\003\000\
\\079\000\082\000\004\000\005\000\
\\126\000\039\000\087\000\080\000\
\\126\000\128\000\056\000\130\000\
\\127\000\064\000\006\000\008\000\
\\007\000\003\000\009\000\127\000\
\\065\000\005\000\126\000\006\000\
\\066\000\144\000\102\000\101\000\
\\099\000\040\000\125\000\007\000\
\\007\000\103\000\104\000\117\000\
\\046\000\124\000\010\000\011\000\
\\121\000\109\000\067\000\047\000\
\\089\000\068\000\144\000\129\000\
\\127\000\069\000\131\000\144\000\
\\133\000\138\000\140\000\042\000\
\\148\000\132\000\110\000\012\000\
\\145\000\015\000\017\000\026\000\
\\027\000\158\000\144\000\013\000\
\\007\000\007\000\007\000\048\000\
\\076\000\098\000\007\000\008\000\
\\116\000\123\000\120\000\122\000\
\\119\000\018\000\088\000\009\000\
\\144\000\111\000\070\000\144\000\
\\113\000\145\000\017\000\014\000\
\\063\000\136\000\019\000\045\000\
\\057\000\151\000\049\000\160\000\
\\050\000\150\000\152\000\175\000\
\\017\000\143\000\204\000\017\000\
\\017\000\014\000\020\000\146\000\
\\016\000\021\000\172\000\170\000\
\\169\000\000\000\157\000\156\000\
\\058\000\167\000\153\000\108\000\
\\107\000\100\000\097\000\106\000\
\\051\000\118\000\091\000\086\000\
\\093\000\090\000\114\000\144\000\
\\112\000\141\000\142\000\149\000\
\\166\000\012\000\045\000\071\000\
\\139\000\159\000\022\000\154\000\
\\023\000\014\000\176\000\017\000\
\\017\000\017\000\017\000\017\000\
\\017\000\017\000\017\000\017\000\
\\017\000\017\000\017\000\017\000\
\\017\000\017\000\017\000\017\000\
\\017\000\017\000\017\000\017\000\
\\017\000\017\000\017\000\017\000\
\\024\000\180\000\181\000\215\000\
\\062\000\043\000\211\000\210\000\
\\061\000\074\000\059\000\055\000\
\\199\000\178\000\206\000\052\000\
\\053\000\171\000\001\000\155\000\
\\165\000\144\000\105\000\018\000\
\\006\000\115\000\137\000\072\000\
\\144\000\161\000\073\000\163\000\
\\162\000\196\000\192\000\195\000\
\\194\000\193\000\038\000\037\000\
\\036\000\035\000\034\000\033\000\
\\032\000\031\000\030\000\029\000\
\\191\000\189\000\187\000\185\000\
\\183\000\190\000\188\000\186\000\
\\184\000\182\000\177\000\164\000\
\\203\000\025\000\020\000\202\000\
\\147\000\201\000\179\000\017\000\
\\025\000\205\000\017\000\173\000\
\\146\000\017\000\168\000\092\000\
\\041\000\095\000\094\000\144\000\
\\134\000\216\000\217\000\075\000\
\\212\000\213\000\146\000\200\000\
\\207\000\054\000\197\000\209\000\
\\208\000\007\000\135\000\025\000\
\\060\000\174\000\017\000\028\000\
\\044\000\218\000\214\000\198\000\
\\007\000\096\000\077\000"
val gotoT =
"\
\\001\000\034\001\002\000\005\000\003\000\004\000\004\000\003\000\
\\015\000\002\000\016\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\008\000\003\000\004\000\004\000\003\000\015\000\002\000\
\\016\000\001\000\000\000\
\\000\000\
\\000\000\
\\005\000\013\000\000\000\
\\000\000\
\\002\000\015\000\003\000\004\000\004\000\003\000\015\000\002\000\
\\016\000\001\000\000\000\
\\000\000\
\\019\000\018\000\020\000\017\000\000\000\
\\018\000\021\000\050\000\020\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\018\000\028\000\050\000\027\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\018\000\032\000\000\000\
\\000\000\
\\010\000\038\000\011\000\037\000\012\000\036\000\013\000\035\000\
\\014\000\034\000\000\000\
\\051\000\044\000\052\000\043\000\000\000\
\\012\000\049\000\013\000\035\000\014\000\034\000\000\000\
\\005\000\050\000\000\000\
\\006\000\051\000\000\000\
\\018\000\053\000\000\000\
\\000\000\
\\019\000\055\000\020\000\017\000\000\000\
\\018\000\057\000\050\000\056\000\000\000\
\\010\000\058\000\011\000\037\000\012\000\036\000\013\000\035\000\
\\014\000\034\000\000\000\
\\000\000\
\\021\000\066\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\013\000\080\000\014\000\079\000\000\000\
\\012\000\081\000\013\000\035\000\014\000\034\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\093\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\018\000\094\000\000\000\
\\000\000\
\\000\000\
\\021\000\096\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\047\000\101\000\048\000\100\000\000\000\
\\023\000\064\000\024\000\063\000\025\000\062\000\026\000\104\000\000\000\
\\023\000\064\000\024\000\108\000\027\000\107\000\028\000\106\000\000\000\
\\029\000\114\000\031\000\113\000\033\000\112\000\034\000\111\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\129\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\030\000\128\000\000\000\
\\023\000\130\000\000\000\
\\013\000\132\000\014\000\131\000\000\000\
\\011\000\133\000\012\000\036\000\013\000\035\000\014\000\034\000\000\000\
\\012\000\134\000\013\000\035\000\014\000\034\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\136\000\012\000\036\000\013\000\035\000\014\000\034\000\000\000\
\\051\000\137\000\052\000\043\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\007\000\139\000\008\000\138\000\000\000\
\\000\000\
\\006\000\141\000\000\000\
\\021\000\142\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\021\000\144\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\023\000\064\000\024\000\063\000\025\000\062\000\026\000\145\000\000\000\
\\029\000\114\000\031\000\146\000\033\000\112\000\034\000\111\000\000\000\
\\023\000\064\000\024\000\147\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\050\000\151\000\000\000\
\\000\000\
\\023\000\130\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\023\000\130\000\000\000\
\\000\000\
\\029\000\114\000\031\000\158\000\033\000\112\000\034\000\111\000\000\000\
\\000\000\
\\000\000\
\\029\000\114\000\031\000\185\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\186\000\033\000\112\000\034\000\111\000\000\000\
\\023\000\189\000\042\000\188\000\043\000\187\000\000\000\
\\039\000\192\000\040\000\191\000\041\000\190\000\000\000\
\\022\000\194\000\023\000\064\000\024\000\063\000\025\000\062\000\
\\026\000\061\000\000\000\
\\029\000\114\000\031\000\196\000\033\000\112\000\034\000\111\000\
\\046\000\195\000\000\000\
\\029\000\114\000\031\000\200\000\033\000\112\000\034\000\111\000\
\\035\000\199\000\036\000\198\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\209\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\047\000\101\000\048\000\210\000\000\000\
\\050\000\211\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\027\000\107\000\028\000\213\000\000\000\
\\000\000\
\\000\000\
\\023\000\216\000\000\000\
\\000\000\
\\029\000\114\000\031\000\217\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\218\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\219\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\220\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\221\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\222\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\223\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\224\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\225\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\226\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\227\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\228\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\229\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\230\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\231\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\232\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\233\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\234\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\235\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\236\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\237\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\238\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\239\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\240\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\031\000\241\000\033\000\112\000\034\000\111\000\000\000\
\\029\000\114\000\033\000\242\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\129\000\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\030\000\002\001\000\000\
\\000\000\
\\007\000\003\001\008\000\138\000\000\000\
\\009\000\006\001\010\000\005\001\011\000\004\001\012\000\036\000\
\\013\000\035\000\014\000\034\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\008\001\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\036\000\010\001\045\000\009\001\000\000\
\\040\000\012\001\041\000\190\000\000\000\
\\000\000\
\\023\000\064\000\024\000\063\000\025\000\013\001\000\000\
\\000\000\
\\000\000\
\\029\000\114\000\031\000\196\000\033\000\112\000\034\000\111\000\
\\046\000\015\001\000\000\
\\035\000\016\001\036\000\198\000\000\000\
\\000\000\
\\029\000\114\000\031\000\018\001\032\000\017\001\033\000\112\000\
\\034\000\111\000\000\000\
\\000\000\
\\022\000\019\001\023\000\064\000\024\000\063\000\025\000\062\000\
\\026\000\061\000\000\000\
\\029\000\114\000\031\000\020\001\033\000\112\000\034\000\111\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\021\000\022\001\022\000\065\000\023\000\064\000\024\000\063\000\
\\025\000\062\000\026\000\061\000\029\000\060\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\022\000\024\001\023\000\064\000\024\000\063\000\025\000\062\000\
\\026\000\061\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\028\001\012\000\027\001\013\000\035\000\014\000\034\000\000\000\
\\000\000\
\\035\000\029\001\036\000\198\000\000\000\
\\000\000\
\\000\000\
\\029\000\114\000\031\000\018\001\032\000\031\001\033\000\112\000\
\\034\000\111\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\012\000\033\001\013\000\035\000\014\000\034\000\000\000\
\\000\000\
\\000\000\
\"
val numstates = 291
val numrules = 146
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | CHAR of unit ->  (string) | OPER of unit ->  (string)
 | STRING of unit ->  (string) | FLOAT of unit ->  (string)
 | NUM of unit ->  (string) | COMB_ID of unit ->  (string)
 | ID of unit ->  (string) | bars1toN of unit ->  (unit)
 | bars0toN of unit ->  (unit) | fpID of unit ->  (string*int)
 | fparamList of unit ->  ( ( string * int )  list)
 | formalParams of unit ->  ( ( string * int )  list)
 | recurParas of unit ->  ( ( string * int )  list)
 | recursiveFunList of unit ->  ( ( string*int* YTerm )  list)
 | recursiveFunction of unit ->  (string*int*YTerm)
 | listItems of unit ->  (YTerm)
 | dtrPhraseList of unit ->  ( ( string *YTerm )  list)
 | unfoldPattList of unit ->  ( ( YPattern * (string * YTerm) list )  list)
 | unfoldPatt of unit ->  ( ( string * YTerm )  list)
 | unfold of unit ->  (YTerm) | foldPhrase of unit ->  (string*YTerm)
 | foldPhraseList of unit ->  ( ( string * YTerm )  list)
 | fold of unit ->  (YTerm) | casePhrase of unit ->  (string*YTerm)
 | multipleCasePhrase of unit ->  ( ( string * YTerm )  list)
 | recordPhrase of unit ->  (string*YTerm)
 | recordPhraseList of unit ->  ( ( string * YTerm )  list)
 | record of unit ->  (YTerm) | funterm of unit ->  (YTerm)
 | termList of unit ->  (YTerm list) | term of unit ->  (YTerm)
 | functionBodyList of unit ->  (YTerm list)
 | functionCall of unit ->  (YTerm)
 | recPatternList of unit ->  ( ( string * YPattern )  list)
 | recPattern of unit ->  (string*YPattern)
 | casephraseList of unit ->  ( ( YPattern list* YTerm )  list)
 | casephrase of unit ->  (YPattern list*YTerm)
 | patternList of unit ->  (YPattern list)
 | pattern of unit ->  (YPattern)
 | pattAbstraction of unit ->  (YTerm)
 | functionBody of unit ->  (YTerm) | macroDef of unit ->  (YMacroDef)
 | macroList of unit ->  (YMacroDef list)
 | functionSpec of unit ->  (YTypeExp option)
 | functionMacros of unit ->  (YMacroDef list)
 | functionDefinition of unit ->  (YFunDef)
 | aliasDefinition of unit ->  (YAliasDef)
 | termTypeProd of unit ->  (YTypeExp list)
 | singleTermType of unit ->  (YTypeExp)
 | termType of unit ->  (YTypeExp)
 | termTypeList of unit ->  (YTypeExp list)
 | arrowType of unit ->  (YTypeExp)
 | structorType of unit ->  (YTypeExp)
 | structorDef of unit ->  (YStructorDef)
 | structorDefList of unit ->  (YStructorDef list)
 | idList of unit ->  (string list)
 | dataName of unit ->  (string*string list)
 | dataDefinition of unit ->  (YDefinition)
 | definition of unit ->  (YDefinition)
 | definitionList of unit ->  (YDefinition list)
 | program of unit ->  (YDefinition list)
end
type svalue = MlyValue.svalue
type result = YDefinition list
end
structure EC=
struct
open LrTable
val is_keyword =
fn (T 62) => true | (T 63) => true | (T 28) => true | (T 11) => true
 | (T 32) => true | (T 12) => true | (T 13) => true | _ => false
val preferred_change = 
nil
val noShift = 
fn (T 64) => true | _ => false
val showTerminal =
fn (T 0) => "ID"
  | (T 1) => "COMB_ID"
  | (T 2) => "SHARP"
  | (T 3) => "AT"
  | (T 4) => "DONTCARE"
  | (T 5) => "RANGE"
  | (T 6) => "NUM"
  | (T 7) => "FLOAT"
  | (T 8) => "STRING"
  | (T 9) => "OPER"
  | (T 10) => "CHAR"
  | (T 11) => "BAR"
  | (T 12) => "S_ARROW"
  | (T 13) => "D_ARROW"
  | (T 14) => "L_PAR"
  | (T 15) => "R_PAR"
  | (T 16) => "L_BRACKET"
  | (T 17) => "R_BRACKET"
  | (T 18) => "L_BRACE"
  | (T 19) => "R_BRACE"
  | (T 20) => "L_FOLD"
  | (T 21) => "R_FOLD"
  | (T 22) => "L_UNFOLD"
  | (T 23) => "R_UNFOLD"
  | (T 24) => "L_MACBRACE"
  | (T 25) => "R_MACBRACE"
  | (T 26) => "L_RECUR"
  | (T 27) => "R_RECUR"
  | (T 28) => "EQUALS"
  | (T 29) => "COMMA"
  | (T 30) => "COLON"
  | (T 31) => "SEMICOLON"
  | (T 32) => "STOP"
  | (T 33) => "HIGHERORDERCOLON"
  | (T 34) => "ADD"
  | (T 35) => "SUB"
  | (T 36) => "MUL"
  | (T 37) => "DIV"
  | (T 38) => "MOD"
  | (T 39) => "NEG"
  | (T 40) => "FADD"
  | (T 41) => "FSUB"
  | (T 42) => "FMUL"
  | (T 43) => "FDIV"
  | (T 44) => "FMOD"
  | (T 45) => "GT"
  | (T 46) => "GE"
  | (T 47) => "LT"
  | (T 48) => "LE"
  | (T 49) => "FGT"
  | (T 50) => "FGE"
  | (T 51) => "FLT"
  | (T 52) => "FLE"
  | (T 53) => "EQV"
  | (T 54) => "NEQV"
  | (T 55) => "AND"
  | (T 56) => "OR"
  | (T 57) => "XOR"
  | (T 58) => "NOT"
  | (T 59) => "APPEND"
  | (T 60) => "STRCAT"
  | (T 61) => "LISTINS"
  | (T 62) => "DATA"
  | (T 63) => "DEF"
  | (T 64) => "EOF"
  | (T 65) => "APP"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn _ => MlyValue.VOID
end
val terms = (T 2) :: (T 3) :: (T 4) :: (T 5) :: (T 11) :: (T 12) :: 
(T 13) :: (T 14) :: (T 15) :: (T 16) :: (T 17) :: (T 18) :: (T 19) :: 
(T 20) :: (T 21) :: (T 22) :: (T 23) :: (T 24) :: (T 25) :: (T 26) :: 
(T 27) :: (T 28) :: (T 29) :: (T 30) :: (T 31) :: (T 32) :: (T 33) :: 
(T 34) :: (T 35) :: (T 36) :: (T 37) :: (T 38) :: (T 39) :: (T 40) :: 
(T 41) :: (T 42) :: (T 43) :: (T 44) :: (T 45) :: (T 46) :: (T 47) :: 
(T 48) :: (T 49) :: (T 50) :: (T 51) :: (T 52) :: (T 53) :: (T 54) :: 
(T 55) :: (T 56) :: (T 57) :: (T 58) :: (T 59) :: (T 60) :: (T 61) :: 
(T 62) :: (T 63) :: (T 64) :: (T 65) :: nil
end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of (0,(_,(MlyValue.definitionList definitionList1,definitionList1left,
definitionList1right))::rest671) => let val result=MlyValue.program(
fn _ => let val definitionList as definitionList1=definitionList1 ()
 in ( definitionList ) end
)
 in (LrTable.NT 0,(result,definitionList1left,definitionList1right),
rest671) end
| (1,(_,(MlyValue.definitionList definitionList1,_,
definitionList1right))::(_,(MlyValue.definition definition1,
definition1left,_))::rest671) => let val result=
MlyValue.definitionList(fn _ => let val definition as definition1=
definition1 ()
val definitionList as definitionList1=definitionList1 ()
 in ( definition::definitionList ) end
)
 in (LrTable.NT 1,(result,definition1left,definitionList1right),
rest671) end
| (2,(_,(MlyValue.definitionList definitionList1,_,
definitionList1right))::_::(_,(MlyValue.definition definition1,
definition1left,_))::rest671) => let val result=
MlyValue.definitionList(fn _ => let val definition as definition1=
definition1 ()
val definitionList as definitionList1=definitionList1 ()
 in ( definition::definitionList ) end
)
 in (LrTable.NT 1,(result,definition1left,definitionList1right),
rest671) end
| (3,rest671) => let val result=MlyValue.definitionList(fn _ => ( [] )
)
 in (LrTable.NT 1,(result,defaultPos,defaultPos),rest671) end
| (4,(_,(MlyValue.dataDefinition dataDefinition1,dataDefinition1left,
dataDefinition1right))::rest671) => let val result=MlyValue.definition
(fn _ => let val dataDefinition as dataDefinition1=dataDefinition1 ()
 in ( dataDefinition ) end
)
 in (LrTable.NT 2,(result,dataDefinition1left,dataDefinition1right),
rest671) end
| (5,(_,(MlyValue.aliasDefinition aliasDefinition1,
aliasDefinition1left,aliasDefinition1right))::rest671) => let val 
result=MlyValue.definition(fn _ => let val aliasDefinition as 
aliasDefinition1=aliasDefinition1 ()
 in ( yALIASDEF aliasDefinition ) end
)
 in (LrTable.NT 2,(result,aliasDefinition1left,aliasDefinition1right),
rest671) end
| (6,(_,(MlyValue.functionDefinition functionDefinition1,
functionDefinition1left,functionDefinition1right))::rest671) => let 
val result=MlyValue.definition(fn _ => let val functionDefinition as 
functionDefinition1=functionDefinition1 ()
 in ( yFUNDEF   functionDefinition ) end
)
 in (LrTable.NT 2,(result,functionDefinition1left,
functionDefinition1right),rest671) end
| (7,(_,(MlyValue.structorDefList structorDefList1,_,
structorDefList1right))::_::(_,(MlyValue.dataName dataName2,_,_))::_::
(_,(MlyValue.dataName dataName1,_,_))::(_,(_,DATA1left,_))::rest671)
 => let val result=MlyValue.dataDefinition(fn _ => let val dataName1=
dataName1 ()
val dataName2=dataName2 ()
val structorDefList as structorDefList1=structorDefList1 ()
 in (

                 if isInductive (dataName1, dataName2, structorDefList) then
                        let val (aliasname, _) = dataName2
                            val strulist = map (fn (ctr, NONE) => (ctr, [])
                                                 | (ctr, SOME (yARROW(x,_))) => (ctr, x)
                                                 | _ => raise Fail("inductive data in charity.grm")
                                               ) structorDefList
                        in
                            yDATADEF(dataName1, aliasname, strulist)
                        end
                 else if isCoinductive (dataName1, dataName2, structorDefList) then
                        let val (aliasname, _) = dataName1
                            val strulist = map (fn (ctr, SOME(yARROW([c],x))) => (ctr, x)
                                                 | (ctr, SOME(yARROW(dmlst, x))) =>
                                                        (ctr, yARROW(List.take(dmlst,length dmlst -1), x))
                                                 | _ => raise Fail("co-inductive data in charity.grm")
                                               ) structorDefList
                        in
                            yCODATADEF(dataName2, aliasname, strulist)
                        end
                 else
                        raise YACCERR("Parsing error: datatype '" ^ (#1 dataName1) ^
                                      "' is neither inductive nor co-inductive\n")
                
) end
)
 in (LrTable.NT 3,(result,DATA1left,structorDefList1right),rest671)
 end
| (8,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.dataName(fn _ => let val ID as ID1=ID1 ()
 in (ID, []) end
)
 in (LrTable.NT 4,(result,ID1left,ID1right),rest671) end
| (9,(_,(_,_,R_PAR1right))::(_,(MlyValue.idList idList1,_,_))::_::(_,(
MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.dataName(fn _ => let val ID as ID1=ID1 ()
val idList as idList1=idList1 ()
 in (ID, idList) end
)
 in (LrTable.NT 4,(result,ID1left,R_PAR1right),rest671) end
| (10,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.idList(fn _ => let val ID as ID1=ID1 ()
 in ( [ID] ) end
)
 in (LrTable.NT 5,(result,ID1left,ID1right),rest671) end
| (11,(_,(MlyValue.idList idList1,_,idList1right))::_::(_,(MlyValue.ID
 ID1,ID1left,_))::rest671) => let val result=MlyValue.idList(fn _ => 
let val ID as ID1=ID1 ()
val idList as idList1=idList1 ()
 in ( ID::idList ) end
)
 in (LrTable.NT 5,(result,ID1left,idList1right),rest671) end
| (12,(_,(MlyValue.structorDef structorDef1,structorDef1left,
structorDef1right))::rest671) => let val result=
MlyValue.structorDefList(fn _ => let val structorDef as structorDef1=
structorDef1 ()
 in ( [ structorDef ] ) end
)
 in (LrTable.NT 6,(result,structorDef1left,structorDef1right),rest671)
 end
| (13,(_,(MlyValue.structorDefList structorDefList1,_,
structorDefList1right))::_::(_,(MlyValue.structorDef structorDef1,
structorDef1left,_))::rest671) => let val result=
MlyValue.structorDefList(fn _ => let val structorDef as structorDef1=
structorDef1 ()
val structorDefList as structorDefList1=structorDefList1 ()
 in ( structorDef::structorDefList) end
)
 in (LrTable.NT 6,(result,structorDef1left,structorDefList1right),
rest671) end
| (14,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.structorDef(fn _ => let val ID as ID1=ID1 ()
 in ( (ID, NONE) ) end
)
 in (LrTable.NT 7,(result,ID1left,ID1right),rest671) end
| (15,(_,(MlyValue.structorType structorType1,_,structorType1right))::
_::(_,(MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.structorDef(fn _ => let val ID as ID1=ID1 ()
val structorType as structorType1=structorType1 ()
 in ( (ID, SOME structorType) ) end
)
 in (LrTable.NT 7,(result,ID1left,structorType1right),rest671) end
| (16,(_,(MlyValue.arrowType arrowType1,arrowType1left,arrowType1right
))::rest671) => let val result=MlyValue.structorType(fn _ => let val 
arrowType as arrowType1=arrowType1 ()
 in ( arrowType ) end
)
 in (LrTable.NT 8,(result,arrowType1left,arrowType1right),rest671) end
| (17,(_,(MlyValue.termType termType1,_,termType1right))::_::(_,(
MlyValue.termTypeList termTypeList2,_,_))::_::(_,(
MlyValue.termTypeList termTypeList1,termTypeList1left,_))::rest671)
 => let val result=MlyValue.structorType(fn _ => let val termTypeList1
=termTypeList1 ()
val termTypeList2=termTypeList2 ()
val termType as termType1=termType1 ()
 in ( yARROW(termTypeList1, yARROW(termTypeList2, termType)) ) end
)
 in (LrTable.NT 8,(result,termTypeList1left,termType1right),rest671)
 end
| (18,(_,(MlyValue.termType termType1,_,termType1right))::_::(_,(
MlyValue.termTypeList termTypeList1,termTypeList1left,_))::rest671)
 => let val result=MlyValue.arrowType(fn _ => let val termTypeList as 
termTypeList1=termTypeList1 ()
val termType as termType1=termType1 ()
 in ( yARROW(termTypeList, termType) ) end
)
 in (LrTable.NT 9,(result,termTypeList1left,termType1right),rest671)
 end
| (19,(_,(MlyValue.termType termType1,_,termType1right))::(_,(_,
S_ARROW1left,_))::rest671) => let val result=MlyValue.arrowType(fn _
 => let val termType as termType1=termType1 ()
 in ( yARROW([], termType) ) end
)
 in (LrTable.NT 9,(result,S_ARROW1left,termType1right),rest671) end
| (20,(_,(MlyValue.termType termType1,termType1left,termType1right))::
rest671) => let val result=MlyValue.termTypeList(fn _ => let val 
termType as termType1=termType1 ()
 in ( [termType] ) end
)
 in (LrTable.NT 10,(result,termType1left,termType1right),rest671) end
| (21,(_,(MlyValue.termTypeList termTypeList1,_,termTypeList1right))::
_::(_,(MlyValue.termType termType1,termType1left,_))::rest671) => let 
val result=MlyValue.termTypeList(fn _ => let val termType as termType1
=termType1 ()
val termTypeList as termTypeList1=termTypeList1 ()
 in ( termType::termTypeList ) end
)
 in (LrTable.NT 10,(result,termType1left,termTypeList1right),rest671)
 end
| (22,(_,(MlyValue.singleTermType singleTermType1,singleTermType1left,
singleTermType1right))::rest671) => let val result=MlyValue.termType(
fn _ => let val singleTermType as singleTermType1=singleTermType1 ()
 in ( singleTermType ) end
)
 in (LrTable.NT 11,(result,singleTermType1left,singleTermType1right),
rest671) end
| (23,(_,(MlyValue.termTypeProd termTypeProd1,termTypeProd1left,
termTypeProd1right))::rest671) => let val result=MlyValue.termType(fn 
_ => let val termTypeProd as termTypeProd1=termTypeProd1 ()
 in ( yPRODS termTypeProd ) end
)
 in (LrTable.NT 11,(result,termTypeProd1left,termTypeProd1right),
rest671) end
| (24,(_,(MlyValue.NUM NUM1,NUM1left,NUM1right))::rest671) => let val 
result=MlyValue.singleTermType(fn _ => let val NUM as NUM1=NUM1 ()
 in (
 if NUM="1" then
                                                yUNIT
                                          else
                                                raise YACCERR("syntax error:"^NUM)
                                        
) end
)
 in (LrTable.NT 12,(result,NUM1left,NUM1right),rest671) end
| (25,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.singleTermType(fn _ => let val ID as ID1=ID1 ()
 in ( yNAME(ID,[]) ) end
)
 in (LrTable.NT 12,(result,ID1left,ID1right),rest671) end
| (26,(_,(_,_,R_PAR1right))::(_,(MlyValue.termTypeList termTypeList1,_
,_))::_::(_,(MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.singleTermType(fn _ => let val ID as ID1=ID1 ()
val termTypeList as termTypeList1=termTypeList1 ()
 in ( yNAME(ID, termTypeList) ) end
)
 in (LrTable.NT 12,(result,ID1left,R_PAR1right),rest671) end
| (27,(_,(_,_,R_PAR1right))::(_,(MlyValue.termTypeProd termTypeProd1,_
,_))::(_,(_,L_PAR1left,_))::rest671) => let val result=
MlyValue.singleTermType(fn _ => let val termTypeProd as termTypeProd1=
termTypeProd1 ()
 in ( yPRODS termTypeProd ) end
)
 in (LrTable.NT 12,(result,L_PAR1left,R_PAR1right),rest671) end
| (28,(_,(MlyValue.singleTermType singleTermType2,_,
singleTermType2right))::_::(_,(MlyValue.singleTermType singleTermType1
,singleTermType1left,_))::rest671) => let val result=
MlyValue.termTypeProd(fn _ => let val singleTermType1=singleTermType1 
()
val singleTermType2=singleTermType2 ()
 in ( [singleTermType1, singleTermType2] ) end
)
 in (LrTable.NT 13,(result,singleTermType1left,singleTermType2right),
rest671) end
| (29,(_,(MlyValue.termTypeProd termTypeProd1,_,termTypeProd1right))::
_::(_,(MlyValue.singleTermType singleTermType1,singleTermType1left,_))
::rest671) => let val result=MlyValue.termTypeProd(fn _ => let val 
singleTermType as singleTermType1=singleTermType1 ()
val termTypeProd as termTypeProd1=termTypeProd1 ()
 in ( singleTermType::termTypeProd ) end
)
 in (LrTable.NT 13,(result,singleTermType1left,termTypeProd1right),
rest671) end
| (30,(_,(MlyValue.termType termType1,_,termType1right))::_::(_,(
MlyValue.dataName dataName1,_,_))::(_,(_,DATA1left,_))::rest671) => 
let val result=MlyValue.aliasDefinition(fn _ => let val dataName as 
dataName1=dataName1 ()
val termType as termType1=termType1 ()
 in ( (dataName, termType) ) end
)
 in (LrTable.NT 14,(result,DATA1left,termType1right),rest671) end
| (31,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::(_,(MlyValue.ID ID1,
_,_))::(_,(_,DEF1left,_))::rest671) => let val result=
MlyValue.functionDefinition(fn _ => let val ID as ID1=ID1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in ( (ID, functionSpec, [], functionBody) ) end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (32,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::(_,(MlyValue.ID ID1,
_,_))::_::(_,(_,DEF1left,_))::rest671) => let val result=
MlyValue.functionDefinition(fn _ => let val ID as ID1=ID1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in ( (ID, functionSpec, [], functionBody) ) end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (33,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::_::(_,(
MlyValue.macroList macroList1,_,_))::(_,(MlyValue.COMB_ID COMB_ID1,_,_
))::(_,(_,DEF1left,_))::rest671) => let val result=
MlyValue.functionDefinition(fn _ => let val COMB_ID as COMB_ID1=
COMB_ID1 ()
val macroList as macroList1=macroList1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in ( (COMB_ID, functionSpec, macroList, functionBody) ) end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (34,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::(_,(
MlyValue.formalParams formalParams1,_,_))::(_,(MlyValue.ID ID1,_,_))::
(_,(_,DEF1left,_))::rest671) => let val result=
MlyValue.functionDefinition(fn _ => let val ID as ID1=ID1 ()
val formalParams as formalParams1=formalParams1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in (
 (ID, functionSpec,  [], buildNewBody(formalParams, functionBody)))
 end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (35,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::(_,(
MlyValue.formalParams formalParams1,_,_))::(_,(MlyValue.ID ID1,_,_))::
_::(_,(_,DEF1left,_))::rest671) => let val result=
MlyValue.functionDefinition(fn _ => let val ID as ID1=ID1 ()
val formalParams as formalParams1=formalParams1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in (
 (ID, functionSpec,  [], buildNewBody(formalParams, functionBody)))
 end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (36,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.functionSpec functionSpec1,_,_))::(_,(
MlyValue.formalParams formalParams1,_,_))::_::(_,(MlyValue.macroList 
macroList1,_,_))::(_,(MlyValue.COMB_ID COMB_ID1,_,_))::(_,(_,DEF1left,
_))::rest671) => let val result=MlyValue.functionDefinition(fn _ => 
let val COMB_ID as COMB_ID1=COMB_ID1 ()
val macroList as macroList1=macroList1 ()
val formalParams as formalParams1=formalParams1 ()
val functionSpec as functionSpec1=functionSpec1 ()
val functionBody as functionBody1=functionBody1 ()
 in (
 (COMB_ID, functionSpec, macroList, buildNewBody(formalParams, functionBody))
) end
)
 in (LrTable.NT 15,(result,DEF1left,functionBody1right),rest671) end
| (37,(_,(_,_,R_PAR1right))::(_,(MlyValue.fparamList fparamList1,_,_))
::(_,(_,L_PAR1left,_))::rest671) => let val result=
MlyValue.formalParams(fn _ => let val fparamList as fparamList1=
fparamList1 ()
 in (fparamList) end
)
 in (LrTable.NT 49,(result,L_PAR1left,R_PAR1right),rest671) end
| (38,(_,(MlyValue.fpID fpID1,fpID1left,fpID1right))::rest671) => let 
val result=MlyValue.fparamList(fn _ => let val fpID as fpID1=fpID1 ()
 in ([fpID]) end
)
 in (LrTable.NT 50,(result,fpID1left,fpID1right),rest671) end
| (39,(_,(MlyValue.fparamList fparamList1,_,fparamList1right))::_::(_,
(MlyValue.fpID fpID1,fpID1left,_))::rest671) => let val result=
MlyValue.fparamList(fn _ => let val fpID as fpID1=fpID1 ()
val fparamList as fparamList1=fparamList1 ()
 in (fpID::fparamList) end
)
 in (LrTable.NT 50,(result,fpID1left,fparamList1right),rest671) end
| (40,(_,(MlyValue.ID ID1,_,ID1right))::(_,(_,SHARP1left,_))::rest671)
 => let val result=MlyValue.fpID(fn _ => let val ID as ID1=ID1 ()
 in ((ID, 1)) end
)
 in (LrTable.NT 51,(result,SHARP1left,ID1right),rest671) end
| (41,(_,(MlyValue.ID ID1,_,ID1right))::(_,(_,AT1left,_))::rest671)
 => let val result=MlyValue.fpID(fn _ => let val ID as ID1=ID1 ()
 in ((ID, 2)) end
)
 in (LrTable.NT 51,(result,AT1left,ID1right),rest671) end
| (42,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.fpID(fn _ => let val ID as ID1=ID1 ()
 in ((ID, 0)) end
)
 in (LrTable.NT 51,(result,ID1left,ID1right),rest671) end
| (43,(_,(_,_,DONTCARE1right))::(_,(_,SHARP1left,_))::rest671) => let 
val result=MlyValue.fpID(fn _ => (("$p" ^ Utility.newName(), 1)))
 in (LrTable.NT 51,(result,SHARP1left,DONTCARE1right),rest671) end
| (44,(_,(_,_,DONTCARE1right))::(_,(_,AT1left,_))::rest671) => let 
val result=MlyValue.fpID(fn _ => (("$p" ^ Utility.newName(), 2)))
 in (LrTable.NT 51,(result,AT1left,DONTCARE1right),rest671) end
| (45,(_,(_,DONTCARE1left,DONTCARE1right))::rest671) => let val result
=MlyValue.fpID(fn _ => (("$p" ^ Utility.newName(), 0)))
 in (LrTable.NT 51,(result,DONTCARE1left,DONTCARE1right),rest671) end
| (46,(_,(MlyValue.arrowType arrowType1,_,arrowType1right))::(_,(_,
COLON1left,_))::rest671) => let val result=MlyValue.functionSpec(fn _
 => let val arrowType as arrowType1=arrowType1 ()
 in ( SOME arrowType ) end
)
 in (LrTable.NT 17,(result,COLON1left,arrowType1right),rest671) end
| (47,rest671) => let val result=MlyValue.functionSpec(fn _ => ( NONE 
))
 in (LrTable.NT 17,(result,defaultPos,defaultPos),rest671) end
| (48,(_,(MlyValue.macroDef macroDef1,macroDef1left,macroDef1right))::
rest671) => let val result=MlyValue.macroList(fn _ => let val macroDef
 as macroDef1=macroDef1 ()
 in ( [ macroDef ] ) end
)
 in (LrTable.NT 18,(result,macroDef1left,macroDef1right),rest671) end
| (49,(_,(MlyValue.macroList macroList1,_,macroList1right))::_::(_,(
MlyValue.macroDef macroDef1,macroDef1left,_))::rest671) => let val 
result=MlyValue.macroList(fn _ => let val macroDef as macroDef1=
macroDef1 ()
val macroList as macroList1=macroList1 ()
 in ( macroDef::macroList ) end
)
 in (LrTable.NT 18,(result,macroDef1left,macroList1right),rest671) end
| (50,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.macroDef(fn _ => let val ID as ID1=ID1 ()
 in ( (ID, NONE) ) end
)
 in (LrTable.NT 19,(result,ID1left,ID1right),rest671) end
| (51,(_,(MlyValue.arrowType arrowType1,_,arrowType1right))::_::(_,(
MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.macroDef(fn _ => let val ID as ID1=ID1 ()
val arrowType as arrowType1=arrowType1 ()
 in ( (ID, SOME arrowType) ) end
)
 in (LrTable.NT 19,(result,ID1left,arrowType1right),rest671) end
| (52,(_,(MlyValue.pattAbstraction pattAbstraction1,
pattAbstraction1left,pattAbstraction1right))::rest671) => let val 
result=MlyValue.functionBody(fn _ => let val pattAbstraction as 
pattAbstraction1=pattAbstraction1 ()
 in ( pattAbstraction ) end
)
 in (LrTable.NT 20,(result,pattAbstraction1left,pattAbstraction1right)
,rest671) end
| (53,(_,(MlyValue.functionCall functionCall1,functionCall1left,
functionCall1right))::rest671) => let val result=MlyValue.functionBody
(fn _ => let val functionCall as functionCall1=functionCall1 ()
 in ( functionCall ) end
)
 in (LrTable.NT 20,(result,functionCall1left,functionCall1right),
rest671) end
| (54,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.formalParams formalParams1,_,_))::(_,(MlyValue.ID ID1,
ID1left,_))::rest671) => let val result=MlyValue.recursiveFunction(fn 
_ => let val ID as ID1=ID1 ()
val formalParams as formalParams1=formalParams1 ()
val functionBody as functionBody1=functionBody1 ()
 in (

                                        if countRecurParams formalParams = 1 then
                                            (ID, 
                                             findRecurPos formalParams, 
                                             buildNewBody(formalParams,functionBody)
                                            )
                                        else
                                            raise YACCERR("Can only have one recursive parameters")
                                        
) end
)
 in (LrTable.NT 46,(result,ID1left,functionBody1right),rest671) end
| (55,(_,(MlyValue.functionBody functionBody1,_,functionBody1right))::
_::(_,(MlyValue.formalParams formalParams1,_,_))::(_,(MlyValue.ID ID1,
_,_))::(_,(_,SHARP1left,_))::rest671) => let val result=
MlyValue.recursiveFunction(fn _ => let val ID as ID1=ID1 ()
val formalParams as formalParams1=formalParams1 ()
val functionBody as functionBody1=functionBody1 ()
 in (

                                        if countRecurParams formalParams = 0 then
                                            (ID, 
                                             ~1, 
                                             buildNewBody(formalParams,functionBody)
                                            )
                                        else
                                            raise YACCERR("Can only have one recursive parameters")
                                        
) end
)
 in (LrTable.NT 46,(result,SHARP1left,functionBody1right),rest671) end
| (56,(_,(MlyValue.recursiveFunction recursiveFunction1,
recursiveFunction1left,recursiveFunction1right))::rest671) => let val 
result=MlyValue.recursiveFunList(fn _ => let val recursiveFunction as 
recursiveFunction1=recursiveFunction1 ()
 in ( [ recursiveFunction ] ) end
)
 in (LrTable.NT 47,(result,recursiveFunction1left,
recursiveFunction1right),rest671) end
| (57,(_,(MlyValue.recursiveFunList recursiveFunList1,_,
recursiveFunList1right))::_::(_,(MlyValue.recursiveFunction 
recursiveFunction1,recursiveFunction1left,_))::rest671) => let val 
result=MlyValue.recursiveFunList(fn _ => let val recursiveFunction as 
recursiveFunction1=recursiveFunction1 ()
val recursiveFunList as recursiveFunList1=recursiveFunList1 ()
 in ( recursiveFunction::recursiveFunList ) end
)
 in (LrTable.NT 47,(result,recursiveFunction1left,
recursiveFunList1right),rest671) end
| (58,(_,(MlyValue.casephraseList casephraseList1,casephraseList1left,
casephraseList1right))::rest671) => let val result=
MlyValue.pattAbstraction(fn _ => let val casephraseList as 
casephraseList1=casephraseList1 ()
 in ( yPattABS casephraseList ) end
)
 in (LrTable.NT 21,(result,casephraseList1left,casephraseList1right),
rest671) end
| (59,(_,(_,_,R_BRACE1right))::(_,(MlyValue.casephraseList 
casephraseList1,_,_))::(_,(_,L_BRACE1left,_))::rest671) => let val 
result=MlyValue.pattAbstraction(fn _ => let val casephraseList as 
casephraseList1=casephraseList1 ()
 in ( yPattABS casephraseList ) end
)
 in (LrTable.NT 21,(result,L_BRACE1left,R_BRACE1right),rest671) end
| (60,(_,(MlyValue.casephrase casephrase1,casephrase1left,
casephrase1right))::rest671) => let val result=MlyValue.casephraseList
(fn _ => let val casephrase as casephrase1=casephrase1 ()
 in (
 if casephrase=([],yNULL) then [] 
                                                                    else [ casephrase ] 
) end
)
 in (LrTable.NT 25,(result,casephrase1left,casephrase1right),rest671)
 end
| (61,(_,(MlyValue.casephraseList casephraseList1,_,
casephraseList1right))::_::(_,(MlyValue.casephrase casephrase1,
casephrase1left,_))::rest671) => let val result=
MlyValue.casephraseList(fn _ => let val casephrase as casephrase1=
casephrase1 ()
val casephraseList as casephraseList1=casephraseList1 ()
 in (
 if casephrase=([],yNULL) then casephraseList 
                                                                    else casephrase::casephraseList 
) end
)
 in (LrTable.NT 25,(result,casephrase1left,casephraseList1right),
rest671) end
| (62,(_,(MlyValue.term term1,_,term1right))::_::(_,(
MlyValue.patternList patternList1,patternList1left,_))::rest671) => 
let val result=MlyValue.casephrase(fn _ => let val patternList as 
patternList1=patternList1 ()
val term as term1=term1 ()
 in ( (patternList, term)) end
)
 in (LrTable.NT 24,(result,patternList1left,term1right),rest671) end
| (63,(_,(MlyValue.term term1,_,term1right))::(_,(_,D_ARROW1left,_))::
rest671) => let val result=MlyValue.casephrase(fn _ => let val term
 as term1=term1 ()
 in ( ( [], term) ) end
)
 in (LrTable.NT 24,(result,D_ARROW1left,term1right),rest671) end
| (64,rest671) => let val result=MlyValue.casephrase(fn _ => (
 ( [], yNULL) ))
 in (LrTable.NT 24,(result,defaultPos,defaultPos),rest671) end
| (65,(_,(MlyValue.pattern pattern1,pattern1left,pattern1right))::
rest671) => let val result=MlyValue.patternList(fn _ => let val 
pattern as pattern1=pattern1 ()
 in ( [pattern] ) end
)
 in (LrTable.NT 23,(result,pattern1left,pattern1right),rest671) end
| (66,(_,(MlyValue.patternList patternList1,_,patternList1right))::_::
(_,(MlyValue.pattern pattern1,pattern1left,_))::rest671) => let val 
result=MlyValue.patternList(fn _ => let val pattern as pattern1=
pattern1 ()
val patternList as patternList1=patternList1 ()
 in ( (pattern::patternList) ) end
)
 in (LrTable.NT 23,(result,pattern1left,patternList1right),rest671)
 end
| (67,(_,(_,_,R_PAR1right))::(_,(_,L_PAR1left,_))::rest671) => let 
val result=MlyValue.pattern(fn _ => ( ypTUPLE [] ))
 in (LrTable.NT 22,(result,L_PAR1left,R_PAR1right),rest671) end
| (68,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.pattern(fn _ => let val ID as ID1=ID1 ()
 in ( ypVAR ID) end
)
 in (LrTable.NT 22,(result,ID1left,ID1right),rest671) end
| (69,(_,(MlyValue.pattern pattern1,_,pattern1right))::(_,(MlyValue.ID
 ID1,ID1left,_))::rest671) => let val result=MlyValue.pattern(fn _ => 
let val ID as ID1=ID1 ()
val pattern as pattern1=pattern1 ()
 in ( ypCTR(ID, pattern) ) end
)
 in (LrTable.NT 22,(result,ID1left,pattern1right),rest671) end
| (70,(_,(_,_,R_PAR1right))::(_,(MlyValue.patternList patternList1,_,_
))::(_,(_,L_PAR1left,_))::rest671) => let val result=MlyValue.pattern(
fn _ => let val patternList as patternList1=patternList1 ()
 in ( ypTUPLE patternList ) end
)
 in (LrTable.NT 22,(result,L_PAR1left,R_PAR1right),rest671) end
| (71,(_,(MlyValue.NUM NUM2,_,NUM2right))::_::(_,(MlyValue.NUM NUM1,
NUM1left,_))::rest671) => let val result=MlyValue.pattern(fn _ => let 
val NUM1=NUM1 ()
val NUM2=NUM2 ()
 in (
 ypINTRANGE(valOf(Int.fromString(NUM1)), valOf(Int.fromString(NUM2)) )
) end
)
 in (LrTable.NT 22,(result,NUM1left,NUM2right),rest671) end
| (72,(_,(MlyValue.NUM NUM1,_,NUM1right))::(_,(_,RANGE1left,_))::
rest671) => let val result=MlyValue.pattern(fn _ => let val NUM as 
NUM1=NUM1 ()
 in ( ypINTRANGE(valOf(Int.minInt), valOf(Int.fromString(NUM)) )) end
)
 in (LrTable.NT 22,(result,RANGE1left,NUM1right),rest671) end
| (73,(_,(_,_,RANGE1right))::(_,(MlyValue.NUM NUM1,NUM1left,_))::
rest671) => let val result=MlyValue.pattern(fn _ => let val NUM as 
NUM1=NUM1 ()
 in ( ypINTRANGE(valOf(Int.fromString(NUM)), valOf(Int.maxInt)) ) end
)
 in (LrTable.NT 22,(result,NUM1left,RANGE1right),rest671) end
| (74,(_,(_,DONTCARE1left,DONTCARE1right))::rest671) => let val result
=MlyValue.pattern(fn _ => ( ypVAR "_" ))
 in (LrTable.NT 22,(result,DONTCARE1left,DONTCARE1right),rest671) end
| (75,(_,(_,_,R_PAR1right))::(_,(MlyValue.recPatternList 
recPatternList1,_,_))::(_,(_,L_PAR1left,_))::rest671) => let val 
result=MlyValue.pattern(fn _ => let val recPatternList as 
recPatternList1=recPatternList1 ()
 in ( ypRECORD recPatternList ) end
)
 in (LrTable.NT 22,(result,L_PAR1left,R_PAR1right),rest671) end
| (76,(_,(MlyValue.recPattern recPattern1,recPattern1left,
recPattern1right))::rest671) => let val result=MlyValue.recPatternList
(fn _ => let val recPattern as recPattern1=recPattern1 ()
 in ( [ recPattern ] ) end
)
 in (LrTable.NT 27,(result,recPattern1left,recPattern1right),rest671)
 end
| (77,(_,(MlyValue.recPatternList recPatternList1,_,
recPatternList1right))::_::(_,(MlyValue.recPattern recPattern1,
recPattern1left,_))::rest671) => let val result=
MlyValue.recPatternList(fn _ => let val recPattern as recPattern1=
recPattern1 ()
val recPatternList as recPatternList1=recPatternList1 ()
 in ( recPattern::recPatternList ) end
)
 in (LrTable.NT 27,(result,recPattern1left,recPatternList1right),
rest671) end
| (78,(_,(MlyValue.pattern pattern1,_,pattern1right))::_::(_,(
MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.recPattern(fn _ => let val ID as ID1=ID1 ()
val pattern as pattern1=pattern1 ()
 in ( (ID, pattern) ) end
)
 in (LrTable.NT 26,(result,ID1left,pattern1right),rest671) end
| (79,(_,(MlyValue.ID ID2,_,ID2right))::_::(_,(MlyValue.ID ID1,ID1left
,_))::rest671) => let val result=MlyValue.recPattern(fn _ => let val 
ID1=ID1 ()
val ID2=ID2 ()
 in ( (ID1, ypFUN ID2) ) end
)
 in (LrTable.NT 26,(result,ID1left,ID2right),rest671) end
| (80,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.functionCall(fn _ => let val ID as ID1=ID1 ()
 in ( yCOMB(ID, []) ) end
)
 in (LrTable.NT 28,(result,ID1left,ID1right),rest671) end
| (81,(_,(_,_,R_BRACE1right))::(_,(MlyValue.functionBodyList 
functionBodyList1,_,_))::(_,(MlyValue.COMB_ID COMB_ID1,COMB_ID1left,_)
)::rest671) => let val result=MlyValue.functionCall(fn _ => let val 
COMB_ID as COMB_ID1=COMB_ID1 ()
val functionBodyList as functionBodyList1=functionBodyList1 ()
 in ( yCOMB(COMB_ID, functionBodyList) ) end
)
 in (LrTable.NT 28,(result,COMB_ID1left,R_BRACE1right),rest671) end
| (82,(_,(_,_,R_RECUR1right))::(_,(MlyValue.recursiveFunList 
recursiveFunList1,_,_))::(_,(_,L_RECUR1left,_))::rest671) => let val 
result=MlyValue.functionCall(fn _ => let val recursiveFunList as 
recursiveFunList1=recursiveFunList1 ()
 in ( yLOCALFUN recursiveFunList ) end
)
 in (LrTable.NT 28,(result,L_RECUR1left,R_RECUR1right),rest671) end
| (83,(_,(MlyValue.functionBody functionBody1,functionBody1left,
functionBody1right))::rest671) => let val result=
MlyValue.functionBodyList(fn _ => let val functionBody as 
functionBody1=functionBody1 ()
 in ( [functionBody] ) end
)
 in (LrTable.NT 29,(result,functionBody1left,functionBody1right),
rest671) end
| (84,(_,(MlyValue.functionBodyList functionBodyList1,_,
functionBodyList1right))::_::(_,(MlyValue.functionBody functionBody1,
functionBody1left,_))::rest671) => let val result=
MlyValue.functionBodyList(fn _ => let val functionBody as 
functionBody1=functionBody1 ()
val functionBodyList as functionBodyList1=functionBodyList1 ()
 in ( functionBody::functionBodyList ) end
)
 in (LrTable.NT 29,(result,functionBody1left,functionBodyList1right),
rest671) end
| (85,(_,(MlyValue.ID ID1,ID1left,ID1right))::rest671) => let val 
result=MlyValue.term(fn _ => let val ID as ID1=ID1 ()
 in ( yVAR ID ) end
)
 in (LrTable.NT 30,(result,ID1left,ID1right),rest671) end
| (86,(_,(MlyValue.NUM NUM1,NUM1left,NUM1right))::rest671) => let val 
result=MlyValue.term(fn _ => let val NUM as NUM1=NUM1 ()
 in ( yINT (valOf(Int.fromString(NUM))) ) end
)
 in (LrTable.NT 30,(result,NUM1left,NUM1right),rest671) end
| (87,(_,(MlyValue.FLOAT FLOAT1,FLOAT1left,FLOAT1right))::rest671) => 
let val result=MlyValue.term(fn _ => let val FLOAT as FLOAT1=FLOAT1 ()
 in ( yFLOAT FLOAT ) end
)
 in (LrTable.NT 30,(result,FLOAT1left,FLOAT1right),rest671) end
| (88,(_,(_,_,R_PAR1right))::(_,(_,L_PAR1left,_))::rest671) => let 
val result=MlyValue.term(fn _ => ( yNULL ))
 in (LrTable.NT 30,(result,L_PAR1left,R_PAR1right),rest671) end
| (89,(_,(MlyValue.STRING STRING1,STRING1left,STRING1right))::rest671)
 => let val result=MlyValue.term(fn _ => let val STRING as STRING1=
STRING1 ()
 in ( ySTR STRING ) end
)
 in (LrTable.NT 30,(result,STRING1left,STRING1right),rest671) end
| (90,(_,(_,_,R_PAR1right))::(_,(MlyValue.term term1,_,_))::(_,(_,
L_PAR1left,_))::rest671) => let val result=MlyValue.term(fn _ => let 
val term as term1=term1 ()
 in ( term ) end
)
 in (LrTable.NT 30,(result,L_PAR1left,R_PAR1right),rest671) end
| (91,(_,(_,_,R_PAR1right))::(_,(MlyValue.termList termList1,_,_))::_
::(_,(MlyValue.term term1,_,_))::(_,(_,L_PAR1left,_))::rest671) => 
let val result=MlyValue.term(fn _ => let val term as term1=term1 ()
val termList as termList1=termList1 ()
 in ( yTUPLE(term::termList) ) end
)
 in (LrTable.NT 30,(result,L_PAR1left,R_PAR1right),rest671) end
| (92,(_,(MlyValue.record record1,record1left,record1right))::rest671)
 => let val result=MlyValue.term(fn _ => let val record as record1=
record1 ()
 in ( record ) end
)
 in (LrTable.NT 30,(result,record1left,record1right),rest671) end
| (93,(_,(MlyValue.term term1,_,term1right))::(_,(MlyValue.funterm 
funterm1,funterm1left,_))::rest671) => let val result=MlyValue.term(
fn _ => let val funterm as funterm1=funterm1 ()
val term as term1=term1 ()
 in ( yAPP(funterm, term) ) end
)
 in (LrTable.NT 30,(result,funterm1left,term1right),rest671) end
| (94,(_,(MlyValue.funterm funterm1,_,funterm1right))::_::(_,(
MlyValue.term term1,term1left,_))::rest671) => let val result=
MlyValue.term(fn _ => let val term as term1=term1 ()
val funterm as funterm1=funterm1 ()
 in ( yAPP(funterm, term) ) end
)
 in (LrTable.NT 30,(result,term1left,funterm1right),rest671) end
| (95,(_,(_,_,R_BRACKET1right))::(_,(_,L_BRACKET1left,_))::rest671)
 => let val result=MlyValue.term(fn _ => ( yCOMB("nil",[]) ))
 in (LrTable.NT 30,(result,L_BRACKET1left,R_BRACKET1right),rest671)
 end
| (96,(_,(_,_,R_BRACKET1right))::(_,(MlyValue.listItems listItems1,_,_
))::(_,(_,L_BRACKET1left,_))::rest671) => let val result=MlyValue.term
(fn _ => let val listItems as listItems1=listItems1 ()
 in ( listItems ) end
)
 in (LrTable.NT 30,(result,L_BRACKET1left,R_BRACKET1right),rest671)
 end
| (97,(_,(MlyValue.term term1,_,term1right))::(_,(_,NOT1left,_))::
rest671) => let val result=MlyValue.term(fn _ => let val term as term1
=term1 ()
 in ( yAPP(yCOMB("not",[]),       term)                 ) end
)
 in (LrTable.NT 30,(result,NOT1left,term1right),rest671) end
| (98,(_,(MlyValue.term term1,_,term1right))::(_,(_,NEG1left,_))::
rest671) => let val result=MlyValue.term(fn _ => let val term as term1
=term1 ()
 in ( yAPP(yCOMB("#neg",[]),      term)                 ) end
)
 in (LrTable.NT 30,(result,NEG1left,term1right),rest671) end
| (99,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op+",[]),   yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (100,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op+f",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (101,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op-",[]),   yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (102,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op-f",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (103,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op*",[]),   yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (104,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op*f",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (105,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op/",[]),   yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (106,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op/f",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (107,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("opmod",[]),   yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (108,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#mod_float",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (109,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op>",[]),     yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (110,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op>=",[]),    yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (111,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op<",[]),     yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (112,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op<=",[]),    yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (113,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op^",[]),     yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (114,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#gt_float",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (115,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#ge_float",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (116,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#lt_float",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (117,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#le_float",[]), yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (118,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op==", []),     yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (119,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("op<>",[]),      yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (120,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("and",[]),       yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (121,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("or",[]),        yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (122,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("#xor",[]),      yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (123,(_,(MlyValue.term term2,_,term2right))::_::(_,(MlyValue.term 
term1,term1left,_))::rest671) => let val result=MlyValue.term(fn _ => 
let val term1=term1 ()
val term2=term2 ()
 in ( yAPP(yCOMB("cons",[]),      yTUPLE[term1, term2]) ) end
)
 in (LrTable.NT 30,(result,term1left,term2right),rest671) end
| (124,(_,(MlyValue.term term1,term1left,term1right))::rest671) => 
let val result=MlyValue.termList(fn _ => let val term as term1=term1 
()
 in ( [ term ] ) end
)
 in (LrTable.NT 31,(result,term1left,term1right),rest671) end
| (125,(_,(MlyValue.termList termList1,_,termList1right))::_::(_,(
MlyValue.term term1,term1left,_))::rest671) => let val result=
MlyValue.termList(fn _ => let val term as term1=term1 ()
val termList as termList1=termList1 ()
 in ( term::termList ) end
)
 in (LrTable.NT 31,(result,term1left,termList1right),rest671) end
| (126,(_,(MlyValue.term term1,term1left,term1right))::rest671) => 
let val result=MlyValue.listItems(fn _ => let val term as term1=term1 
()
 in ( yAPP(yCOMB("cons",[]), yTUPLE[term, yCOMB("nil",[])]) ) end
)
 in (LrTable.NT 45,(result,term1left,term1right),rest671) end
| (127,(_,(MlyValue.listItems listItems1,_,listItems1right))::_::(_,(
MlyValue.term term1,term1left,_))::rest671) => let val result=
MlyValue.listItems(fn _ => let val term as term1=term1 ()
val listItems as listItems1=listItems1 ()
 in ( yAPP(yCOMB("cons",[]), yTUPLE[term, listItems]) ) end
)
 in (LrTable.NT 45,(result,term1left,listItems1right),rest671) end
| (128,(_,(_,_,R_BRACE1right))::(_,(MlyValue.pattAbstraction 
pattAbstraction1,_,_))::(_,(_,L_BRACE1left,_))::rest671) => let val 
result=MlyValue.funterm(fn _ => let val pattAbstraction as 
pattAbstraction1=pattAbstraction1 ()
 in ( pattAbstraction ) end
)
 in (LrTable.NT 32,(result,L_BRACE1left,R_BRACE1right),rest671) end
| (129,(_,(_,_,R_FOLD1right))::(_,(MlyValue.fold fold1,_,_))::(_,(_,
L_FOLD1left,_))::rest671) => let val result=MlyValue.funterm(fn _ => 
let val fold as fold1=fold1 ()
 in ( fold ) end
)
 in (LrTable.NT 32,(result,L_FOLD1left,R_FOLD1right),rest671) end
| (130,(_,(_,_,R_UNFOLD1right))::(_,(MlyValue.unfold unfold1,_,_))::(_
,(_,L_UNFOLD1left,_))::rest671) => let val result=MlyValue.funterm(fn 
_ => let val unfold as unfold1=unfold1 ()
 in ( unfold ) end
)
 in (LrTable.NT 32,(result,L_UNFOLD1left,R_UNFOLD1right),rest671) end
| (131,(_,(MlyValue.functionCall functionCall1,functionCall1left,
functionCall1right))::rest671) => let val result=MlyValue.funterm(fn _
 => let val functionCall as functionCall1=functionCall1 ()
 in ( functionCall ) end
)
 in (LrTable.NT 32,(result,functionCall1left,functionCall1right),
rest671) end
| (132,(_,(_,_,R_PAR1right))::(_,(MlyValue.recordPhraseList 
recordPhraseList1,_,_))::(_,(_,L_PAR1left,_))::rest671) => let val 
result=MlyValue.record(fn _ => let val recordPhraseList as 
recordPhraseList1=recordPhraseList1 ()
 in ( yRECORD recordPhraseList ) end
)
 in (LrTable.NT 33,(result,L_PAR1left,R_PAR1right),rest671) end
| (133,(_,(MlyValue.recordPhrase recordPhrase1,recordPhrase1left,
recordPhrase1right))::rest671) => let val result=
MlyValue.recordPhraseList(fn _ => let val recordPhrase as 
recordPhrase1=recordPhrase1 ()
 in ( [recordPhrase] ) end
)
 in (LrTable.NT 34,(result,recordPhrase1left,recordPhrase1right),
rest671) end
| (134,(_,(MlyValue.recordPhraseList recordPhraseList1,_,
recordPhraseList1right))::_::(_,(MlyValue.recordPhrase recordPhrase1,
recordPhrase1left,_))::rest671) => let val result=
MlyValue.recordPhraseList(fn _ => let val recordPhrase as 
recordPhrase1=recordPhrase1 ()
val recordPhraseList as recordPhraseList1=recordPhraseList1 ()
 in ( recordPhrase::recordPhraseList ) end
)
 in (LrTable.NT 34,(result,recordPhrase1left,recordPhraseList1right),
rest671) end
| (135,(_,(MlyValue.term term1,_,term1right))::_::(_,(MlyValue.ID ID1,
ID1left,_))::rest671) => let val result=MlyValue.recordPhrase(fn _ => 
let val ID as ID1=ID1 ()
val term as term1=term1 ()
 in ( (ID, term) ) end
)
 in (LrTable.NT 35,(result,ID1left,term1right),rest671) end
| (136,(_,(MlyValue.pattAbstraction pattAbstraction1,_,
pattAbstraction1right))::_::(_,(MlyValue.ID ID1,ID1left,_))::rest671)
 => let val result=MlyValue.recordPhrase(fn _ => let val ID as ID1=ID1
 ()
val pattAbstraction as pattAbstraction1=pattAbstraction1 ()
 in ( (ID, pattAbstraction) ) end
)
 in (LrTable.NT 35,(result,ID1left,pattAbstraction1right),rest671) end
| (137,(_,(MlyValue.foldPhraseList foldPhraseList1,foldPhraseList1left
,foldPhraseList1right))::rest671) => let val result=MlyValue.fold(fn _
 => let val foldPhraseList as foldPhraseList1=foldPhraseList1 ()
 in ( yFOLD foldPhraseList ) end
)
 in (LrTable.NT 38,(result,foldPhraseList1left,foldPhraseList1right),
rest671) end
| (138,(_,(MlyValue.foldPhrase foldPhrase1,foldPhrase1left,
foldPhrase1right))::rest671) => let val result=MlyValue.foldPhraseList
(fn _ => let val foldPhrase as foldPhrase1=foldPhrase1 ()
 in ( [foldPhrase] ) end
)
 in (LrTable.NT 39,(result,foldPhrase1left,foldPhrase1right),rest671)
 end
| (139,(_,(MlyValue.foldPhraseList foldPhraseList1,_,
foldPhraseList1right))::_::(_,(MlyValue.foldPhrase foldPhrase1,
foldPhrase1left,_))::rest671) => let val result=
MlyValue.foldPhraseList(fn _ => let val foldPhrase as foldPhrase1=
foldPhrase1 ()
val foldPhraseList as foldPhraseList1=foldPhraseList1 ()
 in ( foldPhrase::foldPhraseList ) end
)
 in (LrTable.NT 39,(result,foldPhrase1left,foldPhraseList1right),
rest671) end
| (140,(_,(MlyValue.casephrase casephrase1,_,casephrase1right))::_::(_
,(MlyValue.ID ID1,ID1left,_))::rest671) => let val result=
MlyValue.foldPhrase(fn _ => let val ID as ID1=ID1 ()
val casephrase as casephrase1=casephrase1 ()
 in ( (ID, yPattABS [ casephrase ]) ) end
)
 in (LrTable.NT 40,(result,ID1left,casephrase1right),rest671) end
| (141,(_,(_,_,R_BRACE1right))::(_,(MlyValue.pattAbstraction 
pattAbstraction1,_,_))::_::_::(_,(MlyValue.ID ID1,ID1left,_))::rest671
) => let val result=MlyValue.foldPhrase(fn _ => let val ID as ID1=ID1 
()
val pattAbstraction as pattAbstraction1=pattAbstraction1 ()
 in ( (ID, pattAbstraction) ) end
)
 in (LrTable.NT 40,(result,ID1left,R_BRACE1right),rest671) end
| (142,(_,(MlyValue.unfoldPatt unfoldPatt1,unfoldPatt1left,
unfoldPatt1right))::rest671) => let val result=MlyValue.unfold(fn _
 => let val unfoldPatt as unfoldPatt1=unfoldPatt1 ()
 in ( yUNFOLD unfoldPatt ) end
)
 in (LrTable.NT 41,(result,unfoldPatt1left,unfoldPatt1right),rest671)
 end
| (143,(_,(MlyValue.dtrPhraseList dtrPhraseList1,_,dtrPhraseList1right
))::_::(_,(MlyValue.pattern pattern1,pattern1left,_))::rest671) => 
let val result=MlyValue.unfoldPatt(fn _ => let val pattern as pattern1
=pattern1 ()
val dtrPhraseList as dtrPhraseList1=dtrPhraseList1 ()
 in ( map (addpattern pattern) dtrPhraseList ) end
)
 in (LrTable.NT 42,(result,pattern1left,dtrPhraseList1right),rest671)
 end
| (144,(_,(MlyValue.recordPhrase recordPhrase1,recordPhrase1left,
recordPhrase1right))::rest671) => let val result=
MlyValue.dtrPhraseList(fn _ => let val recordPhrase as recordPhrase1=
recordPhrase1 ()
 in ( [ recordPhrase ] ) end
)
 in (LrTable.NT 44,(result,recordPhrase1left,recordPhrase1right),
rest671) end
| (145,(_,(MlyValue.recordPhraseList recordPhraseList1,_,
recordPhraseList1right))::_::(_,(MlyValue.recordPhrase recordPhrase1,
recordPhrase1left,_))::rest671) => let val result=
MlyValue.dtrPhraseList(fn _ => let val recordPhrase as recordPhrase1=
recordPhrase1 ()
val recordPhraseList as recordPhraseList1=recordPhraseList1 ()
 in ( recordPhrase::recordPhraseList ) end
)
 in (LrTable.NT 44,(result,recordPhrase1left,recordPhraseList1right),
rest671) end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.program x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : ch_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
fun COMB_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.COMB_ID (fn () => i),p1,p2))
fun SHARP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun AT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun DONTCARE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun RANGE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun NUM (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.NUM (fn () => i),p1,p2))
fun FLOAT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.FLOAT (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun OPER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.OPER (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun S_ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun D_ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun L_PAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun R_PAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun L_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun R_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun L_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun R_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun L_FOLD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun R_FOLD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun L_UNFOLD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun R_UNFOLD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun L_MACBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun R_MACBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun L_RECUR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun R_RECUR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun STOP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun HIGHERORDERCOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun SUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun MUL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun DIV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun MOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun NEG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun FADD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun FSUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun FMUL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun FDIV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun FMOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun GT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun GE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun LT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun LE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun FGT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun FGE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun FLT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun FLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun EQV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun NEQV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun OR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun XOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun NOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun APPEND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun STRCAT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun LISTINS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun DATA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.VOID,p1,p2))
fun DEF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun APP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
end
end
